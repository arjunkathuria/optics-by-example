1. Quess 1.

   List the lenses which would be generated by the following makeLenses call, including their types.

   #+begin_src haskell
     data Inventory =
       Inventory { _wand  :: Wand
                 , _book  :: Book
                 , _potions :: [Potion]
                 }

     makeLenses ''Inventory
   #+end_src

   Ans 1:-

   #+begin_src haskell
     wand :: Lens' Inventory Wand
     book :: Lens' Inventory Book
     potions :: Lens' Inventory [Potion]
   #+end_src

2. Quess 2.

  Using the heuristics in this chapter, rewrite the following type as a Lens':

  #+begin_src haskell
  gazork :: Functor f => (Spuzz -> f Spuzz) -> Chumble -> f Chumble
  #+end_src

  #+begin_src haskell
  -- Fill in the blanks:
  gazork :: Lens' _ _
  #+end_src

  Ans 2.

  #+begin_src haskell
    gazork :: Lens' Chumble Spuzz
  #+end_src

3. Quess 3.

   The following code won’t compile! Can you see what’s wrong and fix the problem?

   #+begin_src haskell
     data Pet = Pet
       { _petName :: String
       , _petType :: String
       }

       getPetName :: Pet -> String
       getPetName pet = view petName pet

       makeLenses ''Pet
   #+end_src

   The error says:
     • Variable not in scope: petName :: Lens' Pet String

  Ans 3.

  The Error is brought upon by using the lens `petName` BEFORE the call to makeLenses.
  Since TemplateHaskell expression splits the file into two modules, one above
  and one below.

  The error can simply be migigated by calling makeLenses immediately after
  the data declarations and before the getPetName fn.
